local cloneref = (cloneref or clonereference or function(instance: any)
	return instance
end)

local TweenService = cloneref(game:GetService("TweenService"))
local RunService = cloneref(game:GetService("RunService"))
local InputService = cloneref(game:GetService("UserInputService"))
local TextService = cloneref(game:GetService("TextService"))
local ContentProvider = cloneref(game:GetService("ContentProvider"))
local CoreGui = cloneref(game:GetService("CoreGui"))
local Teams = cloneref(game:GetService("Teams"))
local Players = cloneref(game:GetService("Players"))

local LocalPlayer = Players.LocalPlayer or Players.PlayerAdded:Wait()
local Mouse = cloneref(LocalPlayer:GetMouse())

local setclipboard = setclipboard or nil
local getgenv = getgenv or function()
	return shared
end
local ProtectGui = protectgui or (syn and syn.protect_gui) or function() end
local GetHUI = gethui or function()
	return CoreGui
end

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "MacLib"
ScreenGui.ResetOnSpawn = false
ScreenGui.DisplayOrder = 100
ScreenGui.IgnoreGuiInset = true
ScreenGui.ScreenInsets = Enum.ScreenInsets.None
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local function SafeParentUI(Instance: Instance, Parent: Instance | () -> Instance)
	local success, _error = pcall(function()
		if not Parent then
			Parent = CoreGui
		end
		local DestinationParent
		if typeof(Parent) == "function" then
			DestinationParent = Parent()
		else
			DestinationParent = Parent
		end
		Instance.Parent = DestinationParent
	end)
	if not (success and Instance.Parent) then
		Instance.Parent = LocalPlayer:WaitForChild("PlayerGui", math.huge)
	end
end

local function ParentUI(UI: Instance)
	pcall(ProtectGui, UI)
	SafeParentUI(UI, GetHUI)
end

ParentUI(ScreenGui)

local WindowControls = {
	IsStudio = RunService:IsStudio(),
	AcrylicBlur = true,
	Platform = InputService:GetPlatform(),
	IsMobile = (function()
		if RunService:IsStudio() then
			return InputService.TouchEnabled and not InputService.MouseEnabled
		else
			return InputService:GetPlatform() == Enum.Platform.Android or InputService:GetPlatform() == Enum.Platform.IOS
		end
	end)(),
}

local Library = {
	Registry = {},
	RegistryMap = {},
	HudRegistry = {},
	OpenedFrames = {},
	DependencyBoxes = {},
	DependencyGroupboxes = {},
	UnloadSignals = {},
	Signals = {},
	Toggles = {},
	Options = {},
	Labels = {},
	Buttons = {},
	Tooltips = {},
	ActiveTab = nil,
	TotalTabs = 0,
	ScreenGui = ScreenGui,
	NotifyOnError = false,
	ColorClipboard = nil,
	MinSize = WindowControls.IsMobile and Vector2.new(550, 200) or Vector2.new(550, 300),
}

local function Tween(Instance, TweenInfo, Properties)
	return TweenService:Create(Instance, TweenInfo, Properties)
end

local function ApplyDPIScale(Position)
	return Position
end

local function ApplyTextScale(TextSize)
	return TextSize
end

local function GetTableSize(t)
	local n = 0
	for _, _ in pairs(t) do
		n = n + 1
	end
	return n
end

local function GetPlayers(ExcludeLocalPlayer, ReturnInstances)
	local PlayerList = Players:GetPlayers()
	if ExcludeLocalPlayer then
		local Idx = table.find(PlayerList, LocalPlayer)
		if Idx then
			table.remove(PlayerList, Idx)
		end
	end
	table.sort(PlayerList, function(Player1, Player2)
		return Player1.Name:lower() < Player2.Name:lower()
	end)
	if ReturnInstances == true then
		return PlayerList
	end
	local FixedPlayerList = {}
	for _, player in next, PlayerList do
		FixedPlayerList[#FixedPlayerList + 1] = player.Name
	end
	return FixedPlayerList
end

local function GetTeams(ReturnInstances)
	local TeamList = Teams:GetTeams()
	table.sort(TeamList, function(Team1, Team2)
		return Team1.Name:lower() < Team2.Name:lower()
	end)
	if ReturnInstances == true then
		return TeamList
	end
	local FixedTeamList = {}
	for _, team in next, TeamList do
		FixedTeamList[#FixedTeamList + 1] = team.Name
	end
	return FixedTeamList
end

local function Trim(Text)
	return Text:match("^%s*(.-)%s*$")
end

local function GetTextBounds(text, font, size, resolution)
	return TextService:GetTextSize(text:gsub("<%/?[%w:]+[^>]*>", ""), size, font, resolution or Vector2.new(1920, 1080))
end

Library.Font = Font.new("rbxassetid://12187365364", Enum.FontWeight.Medium, Enum.FontStyle.Normal)
Library.FontColor = Color3.fromRGB(255, 255, 255)
Library.MainColor = Color3.fromRGB(15, 15, 15)
Library.BackgroundColor = Color3.fromRGB(15, 15, 15)
Library.AccentColor = Color3.fromRGB(255, 255, 255)
Library.DisabledAccentColor = Color3.fromRGB(180, 180, 180)
Library.OutlineColor = Color3.fromRGB(255, 255, 255)
Library.DisabledOutlineColor = Color3.fromRGB(180, 180, 180)
Library.DisabledTextColor = Color3.fromRGB(180, 180, 180)
Library.Black = Color3.new(0, 0, 0)
Library.RiskColor = Color3.fromRGB(255, 93, 86)

local assets = {
	interFont = "rbxassetid://12187365364",
	toggleBackground = "rbxassetid://18772190202",
	togglerHead = "rbxassetid://18772309008",
	buttonImage = "rbxassetid://10709791437",
	searchIcon = "rbxassetid://86737463322606",
	dropdownArrow = "rbxassetid://18865373378",
	sliderBar = "rbxassetid://18772615246",
	sliderHead = "rbxassetid://18772834246",
	checker = "rbxassetid://12977615774",
	saturationMap = "rbxassetid://4155801252",
	cursor = "rbxassetid://9619665977",
}

function Library:SafeCallback(Func, ...)
	if Func and typeof(Func) == "function" then
		return table.pack(xpcall(Func, function(Error)
			task.defer(error, debug.traceback(Error, 2))
			if Library.NotifyOnError then
				Library:Notify(Error)
			end
			return Error
		end, ...))
	end
end

function Library:Create(InstanceType, Properties)
	local InstanceValue = InstanceType
	if typeof(InstanceType) == "string" then
		InstanceValue = Instance.new(InstanceType)
	end
	for Property, Value in next, Properties do
		if (Property == "Size" or Property == "Position") then
			Value = ApplyDPIScale(Value)
		elseif Property == "TextSize" then
			Value = ApplyTextScale(Value)
		end
		local success, err = pcall(function()
			InstanceValue[Property] = Value
		end)
		if not success then
			warn(err)
		end
	end
	return InstanceValue
end

function Library:AddToRegistry(Instance, Properties)
	local Data = {Instance = Instance, Properties = Properties}
	table.insert(Library.Registry, Data)
	Library.RegistryMap[Instance] = Data
end

function Library:RemoveFromRegistry(Instance)
	local Data = Library.RegistryMap[Instance]
	if Data then
		for Idx = #Library.Registry, 1, -1 do
			if Library.Registry[Idx] == Data then
				table.remove(Library.Registry, Idx)
			end
		end
		Library.RegistryMap[Instance] = nil
	end
end

function Library:UpdateColorsUsingRegistry()
	for _, Object in next, Library.Registry do
		for Property, ColorIdx in next, Object.Properties do
			if typeof(ColorIdx) == "string" then
				Object.Instance[Property] = Library[ColorIdx] or ColorIdx
			elseif typeof(ColorIdx) == "function" then
				Object.Instance[Property] = ColorIdx()
			end
		end
	end
end

function Library:GiveSignal(Connection)
	if Connection then
		table.insert(Library.Signals, Connection)
	end
	return Connection
end

function Library:Unload()
	for Idx = #Library.Signals, 1, -1 do
		local Connection = table.remove(Library.Signals, Idx)
		if Connection and Connection.Connected then
			Connection:Disconnect()
		end
	end
	for _, UnloadCallback in Library.UnloadSignals do
		Library:SafeCallback(UnloadCallback)
	end
	for _, Tooltip in Library.Tooltips do
		if Tooltip.Destroy then
			Tooltip:Destroy()
		end
	end
	ScreenGui:Destroy()
	Library.Unloaded = true
	getgenv().MacLib = nil
end

function Library:OnUnload(Callback)
	table.insert(Library.UnloadSignals, Callback)
end

Library:GiveSignal(ScreenGui.DescendantRemoving:Connect(function(Instance)
	if Library.RegistryMap[Instance] then
		Library:RemoveFromRegistry(Instance)
	end
end))

function Library:CreateLabel(Properties)
	local Label = Library:Create("TextLabel", {
		BackgroundTransparency = 1,
		Font = Library.Font,
		TextColor3 = Library.FontColor,
		TextSize = 14,
		TextStrokeTransparency = 1,
		RichText = true,
	})
	Library:AddToRegistry(Label, {TextColor3 = "FontColor"})
	return Library:Create(Label, Properties)
end

function Library:MakeDraggable(Instance, Cutoff, IsMainWindow)
	Instance.Active = true
	if not WindowControls.IsMobile then
		Instance.InputBegan:Connect(function(Input)
			if Input.UserInputType == Enum.UserInputType.MouseButton1 then
				if IsMainWindow and Library.CantDragForced then
					return
				end
				local ObjPos = Vector2.new(Mouse.X - Instance.AbsolutePosition.X, Mouse.Y - Instance.AbsolutePosition.Y)
				if ObjPos.Y > (Cutoff or 40) then
					return
				end
				while InputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) do
					Instance.Position = UDim2.new(0, Mouse.X - ObjPos.X + (Instance.Size.X.Offset * Instance.AnchorPoint.X), 0, Mouse.Y - ObjPos.Y + (Instance.Size.Y.Offset * Instance.AnchorPoint.Y))
					RunService.RenderStepped:Wait()
				end
			end
		end)
	else
		local Dragging, DraggingInput, DraggingStart, StartPosition
		InputService.TouchStarted:Connect(function(Input)
			if IsMainWindow and Library.CantDragForced then
				Dragging = false
				return
			end
			if not Dragging and Library:MouseIsOverFrame(Instance, Input) then
				DraggingInput = Input
				DraggingStart = Input.Position
				StartPosition = Instance.Position
				local OffsetPos = Input.Position - DraggingStart
				if OffsetPos.Y > (Cutoff or 40) then
					Dragging = false
					return
				end
				Dragging = true
			end
		end)
		InputService.TouchMoved:Connect(function(Input)
			if Input == DraggingInput and Dragging then
				local OffsetPos = Input.Position - DraggingStart
				Instance.Position = UDim2.new(StartPosition.X.Scale, StartPosition.X.Offset + OffsetPos.X, StartPosition.Y.Scale, StartPosition.Y.Offset + OffsetPos.Y)
			end
		end)
		InputService.TouchEnded:Connect(function(Input)
			if Input == DraggingInput then
				Dragging = false
			end
		end)
	end
end

function Library:MouseIsOverFrame(Frame, Input)
	local Pos = Input and Input.Position or Vector2.new(Mouse.X, Mouse.Y)
	local AbsPos, AbsSize = Frame.AbsolutePosition, Frame.AbsoluteSize
	return Pos.X >= AbsPos.X and Pos.X <= AbsPos.X + AbsSize.X and Pos.Y >= AbsPos.Y and Pos.Y <= AbsPos.Y + AbsSize.Y
end

function Library:MouseIsOverOpenedFrame(Input)
	for Frame, _ in next, Library.OpenedFrames do
		if Library:MouseIsOverFrame(Frame, Input) then
			return true
		end
	end
	return false
end

function Library:AddToolTip(InfoStr, DisabledInfoStr, HoverInstance)
	local Tooltip = Library:Create("Frame", {
		BackgroundColor3 = Library.MainColor,
		BorderColor3 = Library.OutlineColor,
		ZIndex = 100,
		Parent = Library.ScreenGui,
		Visible = false,
	})
	
	local Label = Library:CreateLabel({
		Position = UDim2.fromOffset(3, 1),
		TextSize = 13,
		Text = InfoStr,
		TextXAlignment = Enum.TextXAlignment.Left,
		ZIndex = Tooltip.ZIndex + 1,
		Parent = Tooltip,
	})
	
	Library:AddToRegistry(Tooltip, {BackgroundColor3 = "MainColor", BorderColor3 = "OutlineColor"})
	Library:AddToRegistry(Label, {TextColor3 = "FontColor"})
	
	local TooltipTable = {
		Tooltip = Tooltip,
		Disabled = false,
		Signals = {},
	}
	
	local IsHovering = false
	
	local function UpdateText(Text)
		if Text == nil then return end
		local X, Y = GetTextBounds(Text, Library.Font, 13)
		Label.Text = Text
		Tooltip.Size = UDim2.fromOffset(X + 5, Y + 4)
		Label.Size = UDim2.fromOffset(X, Y)
	end
	
	UpdateText(InfoStr)
	
	local function GiveSignal(Connection)
		if Connection then
			table.insert(TooltipTable.Signals, Connection)
		end
		return Connection
	end
	
	GiveSignal(HoverInstance.MouseEnter:Connect(function()
		if Library:MouseIsOverOpenedFrame() then
			Tooltip.Visible = false
			return
		end
		if not TooltipTable.Disabled then
			UpdateText(InfoStr)
			IsHovering = true
			Tooltip.Position = UDim2.fromOffset(Mouse.X + 15, Mouse.Y + 12)
			Tooltip.Visible = true
			while IsHovering do
				RunService.Heartbeat:Wait()
				Tooltip.Position = UDim2.fromOffset(Mouse.X + 15, Mouse.Y + 12)
			end
			IsHovering = false
			Tooltip.Visible = false
		end
	end))
	
	GiveSignal(HoverInstance.MouseLeave:Connect(function()
		IsHovering = false
		Tooltip.Visible = false
	end))
	
	function TooltipTable:Destroy()
		for _, Connection in ipairs(TooltipTable.Signals) do
			if Connection.Connected then
				Connection:Disconnect()
			end
		end
		Tooltip:Destroy()
	end
	
	table.insert(Library.Tooltips, TooltipTable)
	return TooltipTable
end

function Library:CreateWindow(Settings)
	Settings = Settings or {}
	Settings.Title = Settings.Title or "Window"
	Settings.Subtitle = Settings.Subtitle or ""
	Settings.Size = Settings.Size or UDim2.fromOffset(868, 650)
	Settings.Position = Settings.Position or UDim2.fromScale(0.5, 0.5)
	Settings.DragStyle = Settings.DragStyle or 1
	Settings.AcrylicBlur = Settings.AcrylicBlur ~= nil and Settings.AcrylicBlur or true
	
	local Window = {
		Tabs = {},
		Holder = nil,
	}
	
	local MacLib = ScreenGui
	
	local Base = Library:Create("Frame", {
		Name = "Base",
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundColor3 = Color3.fromRGB(15, 15, 15),
		BackgroundTransparency = Settings.AcrylicBlur and 0.05 or 0,
		BorderSizePixel = 0,
		Position = Settings.Position,
		Size = Settings.Size,
		ZIndex = 1,
		Parent = MacLib,
	})
	
	local BaseUIScale = Library:Create("UIScale", {Parent = Base})
	local BaseUICorner = Library:Create("UICorner", {CornerRadius = UDim.new(0, 10), Parent = Base})
	local BaseUIStroke = Library:Create("UIStroke", {
		ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
		Color = Color3.fromRGB(255, 255, 255),
		Transparency = 0.9,
		Parent = Base,
	})
	
	Library:MakeDraggable(Base, 40, true)
	Window.Holder = Base
	
	local Sidebar = Library:Create("Frame", {
		Name = "Sidebar",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0, 0),
		Size = UDim2.fromScale(0.325, 1),
		Parent = Base,
	})
	
	local SidebarDivider = Library:Create("Frame", {
		Name = "Divider",
		AnchorPoint = Vector2.new(1, 0),
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 0.9,
		BorderSizePixel = 0,
		Position = UDim2.fromScale(1, 0),
		Size = UDim2.new(0, 1, 1, 0),
		Parent = Sidebar,
	})
	
	local WindowControls = Library:Create("Frame", {
		Name = "WindowControls",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 0, 31),
		Parent = Sidebar,
	})
	
	local Controls = Library:Create("Frame", {
		Name = "Controls",
		BackgroundColor3 = Color3.fromRGB(119, 174, 94),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.fromScale(1, 1),
		Parent = WindowControls,
	})
	
	local UIListLayout = Library:Create("UIListLayout", {
		Padding = UDim.new(0, 5),
		FillDirection = Enum.FillDirection.Horizontal,
		SortOrder = Enum.SortOrder.LayoutOrder,
		VerticalAlignment = Enum.VerticalAlignment.Center,
		Parent = Controls,
	})
	
	local UIPadding = Library:Create("UIPadding", {
		PaddingLeft = UDim.new(0, 11),
		Parent = Controls,
	})
	
	local WindowControlSettings = {
		sizes = {enabled = UDim2.fromOffset(8, 8), disabled = UDim2.fromOffset(7, 7)},
		transparencies = {enabled = 0, disabled = 1},
		strokeTransparency = 0.9,
	}
	
	local function ApplyState(button, enabled)
		local size = enabled and WindowControlSettings.sizes.enabled or WindowControlSettings.sizes.disabled
		local transparency = enabled and WindowControlSettings.transparencies.enabled or WindowControlSettings.transparencies.disabled
		button.Size = size
		button.BackgroundTransparency = transparency
		button.Active = enabled
		button.AutoButtonColor = false
		for _, child in ipairs(button:GetChildren()) do
			if child:IsA("UIStroke") then
				child.Transparency = transparency
			end
		end
		if not enabled then
			Library:Create("UIStroke", {
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				Color = Color3.fromRGB(255, 255, 255),
				Transparency = WindowControlSettings.strokeTransparency,
				Parent = button,
			})
		end
	end
	
	local Exit = Library:Create("TextButton", {
		Name = "Exit",
		Text = "",
		BackgroundColor3 = Color3.fromRGB(250, 93, 86),
		BorderSizePixel = 0,
		Parent = Controls,
	})
	Library:Create("UICorner", {CornerRadius = UDim.new(1, 0), Parent = Exit})
	ApplyState(Exit, not (Settings.DisabledWindowControls and table.find(Settings.DisabledWindowControls, "Exit")))
	
	local Minimize = Library:Create("TextButton", {
		Name = "Minimize",
		Text = "",
		BackgroundColor3 = Color3.fromRGB(252, 190, 57),
		BorderSizePixel = 0,
		LayoutOrder = 1,
		Parent = Controls,
	})
	Library:Create("UICorner", {CornerRadius = UDim.new(1, 0), Parent = Minimize})
	ApplyState(Minimize, not (Settings.DisabledWindowControls and table.find(Settings.DisabledWindowControls, "Minimize")))
	
	local Maximize = Library:Create("TextButton", {
		Name = "Maximize",
		Text = "",
		BackgroundColor3 = Color3.fromRGB(119, 174, 94),
		BorderSizePixel = 0,
		LayoutOrder = 1,
		Parent = Controls,
	})
	Library:Create("UICorner", {CornerRadius = UDim.new(1, 0), Parent = Maximize})
	ApplyState(Maximize, false)
	
	local WindowControlsDivider = Library:Create("Frame", {
		Name = "Divider",
		AnchorPoint = Vector2.new(0, 1),
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 0.9,
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0, 1),
		Size = UDim2.new(1, 0, 0, 1),
		Parent = WindowControls,
	})
	
	local Information = Library:Create("Frame", {
		Name = "Information",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Position = UDim2.fromOffset(0, 31),
		Size = UDim2.new(1, 0, 0, 60),
		Parent = Sidebar,
	})
	
	local InformationHolder = Library:Create("Frame", {
		Name = "InformationHolder",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.fromScale(1, 1),
		Parent = Information,
	})
	
	local InformationPadding = Library:Create("UIPadding", {
		PaddingBottom = UDim.new(0, 10),
		PaddingLeft = UDim.new(0, 23),
		PaddingRight = UDim.new(0, 22),
		PaddingTop = UDim.new(0, 10),
		Parent = InformationHolder,
	})
	
	local TitleFrame = Library:Create("Frame", {
		Name = "TitleFrame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.fromScale(1, 1),
		Parent = InformationHolder,
	})
	
	local Title = Library:CreateLabel({
		Name = "Title",
		Text = Settings.Title,
		TextSize = 20,
		TextTransparency = 0.2,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextYAlignment = Enum.TextYAlignment.Top,
		AutomaticSize = Enum.AutomaticSize.Y,
		Size = UDim2.new(1, -20, 0, 0),
		Parent = TitleFrame,
	})
	
	local Subtitle = Library:CreateLabel({
		Name = "Subtitle",
		Text = Settings.Subtitle,
		TextSize = 12,
		TextTransparency = 0.7,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextYAlignment = Enum.TextYAlignment.Top,
		AutomaticSize = Enum.AutomaticSize.Y,
		LayoutOrder = 1,
		Size = UDim2.new(1, -20, 0, 0),
		Parent = TitleFrame,
	})
	
	local TitleLayout = Library:Create("UIListLayout", {
		Padding = UDim.new(0, 3),
		SortOrder = Enum.SortOrder.LayoutOrder,
		VerticalAlignment = Enum.VerticalAlignment.Center,
		Parent = TitleFrame,
	})
	
	local InformationDivider = Library:Create("Frame", {
		Name = "Divider",
		AnchorPoint = Vector2.new(0, 1),
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 0.9,
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0, 1),
		Size = UDim2.new(1, 0, 0, 1),
		Parent = Information,
	})
	
	local SidebarGroup = Library:Create("Frame", {
		Name = "SidebarGroup",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Position = UDim2.fromOffset(0, 91),
		Size = UDim2.new(1, 0, 1, -91),
		Parent = Sidebar,
	})
	
	local SidebarPadding = Library:Create("UIPadding", {
		PaddingLeft = UDim.new(0, 10),
		PaddingRight = UDim.new(0, 10),
		PaddingTop = UDim.new(0, 31),
		Parent = SidebarGroup,
	})
	
	local UserInfo = Library:Create("Frame", {
		Name = "UserInfo",
		AnchorPoint = Vector2.new(0, 1),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0, 1),
		Size = UDim2.new(1, 0, 0, 107),
		Parent = SidebarGroup,
	})
	
	local UserInfoGroup = Library:Create("Frame", {
		Name = "InformationGroup",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.fromScale(1, 1),
		Parent = UserInfo,
	})
	
	local UserInfoPadding = Library:Create("UIPadding", {
		PaddingBottom = UDim.new(0, 17),
		PaddingLeft = UDim.new(0, 25),
		Parent = UserInfoGroup,
	})
	
	local UserInfoLayout = Library:Create("UIListLayout", {
		FillDirection = Enum.FillDirection.Horizontal,
		SortOrder = Enum.SortOrder.LayoutOrder,
		VerticalAlignment = Enum.VerticalAlignment.Center,
		Parent = UserInfoGroup,
	})
	
	local userId = LocalPlayer.UserId
	local thumbType = Enum.ThumbnailType.AvatarBust
	local thumbSize = Enum.ThumbnailSize.Size48x48
	local headshotImage, isReady = Players:GetUserThumbnailAsync(userId, thumbType, thumbSize)
	
	local Headshot = Library:Create("ImageLabel", {
		Name = "Headshot",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.fromOffset(32, 32),
		Image = isReady and headshotImage or "rbxassetid://0",
		Parent = UserInfoGroup,
	})
	Library:Create("UICorner", {CornerRadius = UDim.new(1, 0), Parent = Headshot})
	Library:Create("UIStroke", {
		ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
		Color = Color3.fromRGB(255, 255, 255),
		Transparency = 0.9,
		Parent = Headshot,
	})
	
	local UserAndDisplayFrame = Library:Create("Frame", {
		Name = "UserAndDisplayFrame",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		LayoutOrder = 1,
		Size = UDim2.new(1, -42, 0, 32),
		Parent = UserInfoGroup,
	})
	
	local UserInfoPadding2 = Library:Create("UIPadding", {
		PaddingLeft = UDim.new(0, 8),
		PaddingTop = UDim.new(0, 3),
		Parent = UserAndDisplayFrame,
	})
	
	local UserInfoLayout2 = Library:Create("UIListLayout", {
		Padding = UDim.new(0, 1),
		SortOrder = Enum.SortOrder.LayoutOrder,
		Parent = UserAndDisplayFrame,
	})
	
	local DisplayName = Library:CreateLabel({
		Name = "DisplayName",
		Text = LocalPlayer.DisplayName,
		TextSize = 13,
		TextTransparency = 0.2,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextYAlignment = Enum.TextYAlignment.Top,
		AutomaticSize = Enum.AutomaticSize.XY,
		Size = UDim2.fromScale(1, 0),
		Parent = UserAndDisplayFrame,
	})
	
	local Username = Library:CreateLabel({
		Name = "Username",
		Text = "@" .. LocalPlayer.Name,
		TextSize = 12,
		TextTransparency = 0.8,
		TextXAlignment = Enum.TextXAlignment.Left,
		TextYAlignment = Enum.TextYAlignment.Top,
		AutomaticSize = Enum.AutomaticSize.XY,
		LayoutOrder = 1,
		Size = UDim2.fromScale(1, 0),
		Parent = UserAndDisplayFrame,
	})
	
	local UserInfoPadding3 = Library:Create("UIPadding", {
		PaddingLeft = UDim.new(0, 10),
		PaddingRight = UDim.new(0, 10),
		Parent = UserInfo,
	})
	
	local TabSwitchers = Library:Create("Frame", {
		Name = "TabSwitchers",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 1, -107),
		Parent = SidebarGroup,
	})
	
	local TabScrolling = Library:Create("ScrollingFrame", {
		Name = "TabSwitchersScrollingFrame",
		AutomaticCanvasSize = Enum.AutomaticSize.Y,
		BottomImage = "",
		CanvasSize = UDim2.new(),
		ScrollBarImageTransparency = 0.8,
		ScrollBarThickness = 1,
		TopImage = "",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.fromScale(1, 1),
		Parent = TabSwitchers,
	})
	
	local TabLayout = Library:Create("UIListLayout", {
		Padding = UDim.new(0, 17),
		SortOrder = Enum.SortOrder.LayoutOrder,
		Parent = TabScrolling,
	})
	
	local TabPadding = Library:Create("UIPadding", {
		PaddingTop = UDim.new(0, 2),
		Parent = TabScrolling,
	})
	
	local Content = Library:Create("Frame", {
		Name = "Content",
		AnchorPoint = Vector2.new(1, 0),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Position = UDim2.fromScale(1, 0),
		Size = UDim2.fromScale(0.675, 1),
		Parent = Base,
	})
	
	local Topbar = Library:Create("Frame", {
		Name = "Topbar",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.new(1, 0, 0, 63),
		Parent = Content,
	})
	
	local TopbarDivider = Library:Create("Frame", {
		Name = "Divider",
		AnchorPoint = Vector2.new(0, 1),
		BackgroundColor3 = Color3.fromRGB(255, 255, 255),
		BackgroundTransparency = 0.9,
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0, 1),
		Size = UDim2.new(1, 0, 0, 1),
		Parent = Topbar,
	})
	
	local ContentElements = Library:Create("Frame", {
		Name = "Elements",
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Size = UDim2.fromScale(1, 1),
		Parent = Content,
	})
	
	local ContentPadding = Library:Create("UIPadding", {
		PaddingLeft = UDim.new(0, 20),
		PaddingRight = UDim.new(0, 20),
		Parent = ContentElements,
	})
	
	local MoveIcon = Library:Create("ImageButton", {
		Name = "MoveIcon",
		Image = "rbxassetid://10734900011",
		ImageTransparency = 0.5,
		AnchorPoint = Vector2.new(1, 0.5),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Position = UDim2.fromScale(1, 0.5),
		Size = UDim2.fromOffset(15, 15),
		Visible = not Settings.DragStyle or Settings.DragStyle == 1,
		Parent = ContentElements,
	})
	
	local Interact = Library:Create("TextButton", {
		Name = "Interact",
		Text = "",
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundTransparency = 1,
		BorderSizePixel = 0,
		Position = UDim2.fromScale(0.5, 0.5),
		Size = UDim2.fromOffset(30, 30),
		Parent = MoveIcon,
	})
	
	local function ChangeMoveIconState(State)
		if State == "Default" then
			Tween(MoveIcon, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {ImageTransparency = 0.5}):Play()
		elseif State == "Hover" then
			Tween(MoveIcon, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {ImageTransparency = 0.2}):Play()
		end
	end
	
	Interact.MouseEnter:Connect(function()
		ChangeMoveIconState("Hover")
	end)
	
	Interact.MouseLeave:Connect(function()
		ChangeMoveIconState("Default")
	end)
	
	local dragging = false
	local dragInput, dragStart, startPos
	
	local function update(input)
		local delta = input.Position - dragStart
		Base.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
	
	local function onDragStart(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = Base.Position
			input.Changed:Connect(function()
				if input.UserInputState == Enum.UserInputState.End then
					dragging = false
				end
			end)
		end
	end
	
	local function onDragUpdate(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			dragInput = input
		end
	end
	
	if not Settings.DragStyle or Settings.DragStyle == 1 then
		Interact.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				onDragStart(input)
			end
		end)
		Interact.InputChanged:Connect(onDragUpdate)
		InputService.InputChanged:Connect(function(input)
			if input == dragInput and dragging then
				update(input)
			end
		end)
	elseif Settings.DragStyle == 2 then
		Base.InputBegan:Connect(onDragStart)
		Base.InputChanged:Connect(onDragUpdate)
		InputService.InputChanged:Connect(function(input)
			if input == dragInput and dragging then
				update(input)
			end
		end)
	end
	
	Window.Holder.Visible = Settings.AutoShow or false
	
	function Window:SetWindowTitle(Title)
		Title.Text = Title
	end
	
	function Window:SetWindowSubtitle(SubtitleText)
		Subtitle.Text = SubtitleText
	end
	
	function Window:Tab(Info)
		Info = Info or {}
		Info.Name = Info.Name or "Tab"
		Info.Image = Info.Image
		
		Library.TotalTabs = Library.TotalTabs + 1
		
		local Tab = {
			Name = Info.Name,
			Window = Window,
			Groupboxes = {},
			Instances = {},
		}
		
		local TabButton = Library:Create("TextButton", {
			Name = "TabSwitcher",
			Text = "",
			AutoButtonColor = false,
			AnchorPoint = Vector2.new(0.5, 0),
			BackgroundColor3 = Color3.fromRGB(255, 255, 255),
			BackgroundTransparency = 1,
			BorderSizePixel = 0,
			Position = UDim2.fromScale(0.5, 0),
			Size = UDim2.new(1, -21, 0, 40),
			LayoutOrder = Library.TotalTabs,
			Parent = TabScrolling,
		})
		
		Library:Create("UICorner", {Parent = TabButton})
		Library:Create("UIStroke", {
			ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
			Color = Color3.fromRGB(255, 255, 255),
			Transparency = 1,
			Parent = TabButton,
		})
		
		local TabButtonLayout = Library:Create("UIListLayout", {
			Padding = UDim.new(0, 9),
			FillDirection = Enum.FillDirection.Horizontal,
			SortOrder = Enum.SortOrder.LayoutOrder,
			VerticalAlignment = Enum.VerticalAlignment.Center,
			Parent = TabButton,
		})
		
		if Info.Image then
			local TabImage = Library:Create("ImageLabel", {
				Name = "TabImage",
				Image = Info.Image,
				ImageTransparency = 0.4,
				BackgroundTransparency = 1,
				BorderSizePixel = 0,
				Size = UDim2.fromOffset(16, 16),
				Parent = TabButton,
			})
		end
		
		local TabName = Library:CreateLabel({
			Name = "TabSwitcherName",
			Text = Info.Name,
			TextSize = 16,
			TextTransparency = 0.4,
			TextXAlignment = Enum.TextXAlignment.Left,
			TextYAlignment = Enum.TextYAlignment.Top,
			AutomaticSize = Enum.AutomaticSize.Y,
			Size = UDim2.new(1, -35, 0, 0),
			LayoutOrder = 1,
			Parent = TabButton,
		})
		
		Library:Create("UIPadding", {
			PaddingLeft = UDim.new(0, 24),
			PaddingRight = UDim.new(0, 35),
			PaddingTop = UDim.new(0, 1),
			Parent = TabButton,
		})
		
		local Elements = Library:Create("Frame", {
			Name = "Elements",
			BackgroundTransparency = 1,
			BorderSizePixel = 0,
			Position = UDim2.fromOffset(0, 63),
			Size = UDim2.new(1, 0, 1, -63),
			Visible = false,
			Parent = Content,
		})
		
		Library:Create("UIPadding", {
			PaddingLeft = UDim.new(0, 11),
			PaddingRight = UDim.new(0, 3),
			PaddingTop = UDim.new(0, 5),
			PaddingBottom = UDim.new(0, 15),
			Parent = Elements,
		})
		
		local ContentLayout = Library:Create("UIListLayout", {
			Padding = UDim.new(0, 15),
			FillDirection = Enum.FillDirection.Horizontal,
			SortOrder = Enum.SortOrder.LayoutOrder,
			Parent = Elements,
		})
		
		local Left = Library:Create("Frame", {
			Name = "Left",
			AutomaticSize = Enum.AutomaticSize.Y,
			BackgroundTransparency = 1,
			BorderSizePixel = 0,
			Size = UDim2.new(0.5, -10, 0, 0),
			Parent = Elements,
		})
		
		Library:Create("UIListLayout", {
			Padding = UDim.new(0, 15),
			SortOrder = Enum.SortOrder.LayoutOrder,
			Parent = Left,
		})
		
		local Right = Library:Create("Frame", {
			Name = "Right",
			AutomaticSize = Enum.AutomaticSize.Y,
			BackgroundTransparency = 1,
			BorderSizePixel = 0,
			LayoutOrder = 1,
			Size = UDim2.new(0.5, -10, 0, 0),
			Parent = Elements,
		})
		
		Library:Create("UIListLayout", {
			Padding = UDim.new(0, 15),
			SortOrder = Enum.SortOrder.LayoutOrder,
			Parent = Right,
		})
		
		function Tab:Show()
			for _, Tab in next, Window.Tabs do
				Tab:Hide()
			end
			Elements.Visible = true
			Tween(TabButton.UIStroke, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {Transparency = 0}):Play()
			Tween(TabName, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {TextTransparency = 0}):Play()
			if Info.Image then
				Tween(TabButton.TabImage, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {ImageTransparency = 0}):Play()
			end
			Library.ActiveTab = Tab
		end
		
		function Tab:Hide()
			Elements.Visible = false
			Tween(TabButton.UIStroke, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {Transparency = 1}):Play()
			Tween(TabName, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {TextTransparency = 0.4}):Play()
			if Info.Image then
				Tween(TabButton.TabImage, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {ImageTransparency = 0.4}):Play()
			end
		end
		
		TabButton.MouseButton1Click:Connect(function()
			Tab:Show()
		end)
		
		function Tab:AddGroupbox(Info)
			Info = Info or {}
			Info.Name = Info.Name or "Section"
			Info.Side = Info.Side or 1
			
			local Groupbox = {
				Name = Info.Name,
				Side = Info.Side,
				Instances = {},
				Elements = {},
				Container = nil,
			}
			
			local Section = Library:Create("Frame", {
				Name = "Section",
				AutomaticSize = Enum.AutomaticSize.Y,
				BackgroundTransparency = 0.98,
				BorderSizePixel = 0,
				Size = UDim2.fromScale(1, 0),
				Parent = Info.Side == 1 and Left or Right,
			})
			
			Library:Create("UICorner", {Parent = Section})
			Library:Create("UIStroke", {
				ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				Color = Color3.fromRGB(255, 255, 255),
				Transparency = 0.95,
				Parent = Section,
			})
			
			local SectionLayout = Library:Create("UIListLayout", {
				Padding = UDim.new(0, 10),
				SortOrder = Enum.SortOrder.LayoutOrder,
				Parent = Section,
			})
			
			local SectionPadding = Library:Create("UIPadding", {
				PaddingBottom = UDim.new(0, 20),
				PaddingLeft = UDim.new(0, 20),
				PaddingRight = UDim.new(0, 18),
				PaddingTop = UDim.new(0, 22),
				Parent = Section,
			})
			
			Groupbox.Container = Section
			Groupbox.Instances.Section = Section
			
			function Groupbox:AddBlank(Size, Visible)
				return Library:Create("Frame", {
					BackgroundTransparency = 1,
					Size = UDim2.new(1, 0, 0, Size),
					Visible = typeof(Visible) == "boolean" and Visible or true,
					Parent = Groupbox.Container,
				})
			end
			
			function Groupbox:AddDivider()
				Groupbox:AddBlank(2)
				local DividerOuter = Library:Create("Frame", {
					BackgroundTransparency = 1,
					Size = UDim2.new(1, -4, 0, 5),
					Parent = Groupbox.Container,
				})
				local DividerInner = Library:Create("Frame", {
					BackgroundColor3 = Library.MainColor,
					BorderColor3 = Library.OutlineColor,
					BorderMode = Enum.BorderMode.Inset,
					Size = UDim2.new(1, 0, 1, 0),
					Parent = DividerOuter,
				})
				Library:AddToRegistry(DividerInner, {BackgroundColor3 = "MainColor", BorderColor3 = "OutlineColor"})
				Groupbox:AddBlank(9)
				table.insert(Groupbox.Elements, {Holder = DividerOuter, Type = "Divider"})
			end
			
			function Groupbox:AddLabel(Text, DoesWrap, Idx)
				local Label = {Type = "Label"}
				local TextLabel = Library:CreateLabel({
					Size = UDim2.new(1, -4, 0, 15),
					TextSize = 14,
					Text = Text,
					TextXAlignment = Enum.TextXAlignment.Left,
					RichText = true,
					Parent = Groupbox.Container,
				})
				if DoesWrap then
					local Y = select(2, GetTextBounds(Text, Library.Font, 14, Vector2.new(TextLabel.AbsoluteSize.X, math.huge)))
					TextLabel.Size = UDim2.new(1, -4, 0, Y)
				else
					Library:Create("UIListLayout", {
						Padding = UDim.new(0, 4),
						FillDirection = Enum.FillDirection.Horizontal,
						HorizontalAlignment = Enum.HorizontalAlignment.Right,
						SortOrder = Enum.SortOrder.LayoutOrder,
						Parent = TextLabel,
					})
				end
				Label.TextLabel = TextLabel
				Label.Container = Groupbox.Container
				function Label:SetText(Text)
					TextLabel.Text = Text
					if DoesWrap then
						local Y = select(2, GetTextBounds(Text, Library.Font, 14, Vector2.new(TextLabel.AbsoluteSize.X, math.huge)))
						TextLabel.Size = UDim2.new(1, -4, 0, Y)
					end
				end
				Groupbox:AddBlank(5)
				table.insert(Groupbox.Elements, Label)
				if Idx then
					Library.Labels[Idx] = Label
				else
					table.insert(Library.Labels, Label)
				end
				return Label
			end
			
			function Groupbox:AddButton(Info)
				if type(Info) == "string" then
					Info = {Text = Info, Func = function() end}
				end
				Info.Text = Info.Text or "Button"
				Info.Func = Info.Func or function() end
				
				local Button = {
					Text = Info.Text,
					Disabled = Info.Disabled,
					Locked = false,
					Type = "Button",
					Func = Info.Func,
				}
				
				local ButtonFrame = Library:Create("Frame", {
					Name = "Button",
					AutomaticSize = Enum.AutomaticSize.Y,
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Size = UDim2.new(1, 0, 0, 38),
					Parent = Groupbox.Container,
				})
				
				local ButtonInteract = Library:Create("TextButton", {
					Name = "ButtonInteract",
					Text = Info.Text,
					TextSize = 13,
					TextTransparency = 0.5,
					Font = Library.Font,
					RichText = true,
					TextXAlignment = Enum.TextXAlignment.Left,
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Size = UDim2.fromScale(1, 1),
					Parent = ButtonFrame,
				})
				
				local ButtonImage = Library:Create("ImageLabel", {
					Name = "ButtonImage",
					Image = assets.buttonImage,
					ImageTransparency = 0.5,
					AnchorPoint = Vector2.new(1, 0.5),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.fromScale(1, 0.5),
					Size = UDim2.fromOffset(15, 15),
					Parent = ButtonFrame,
				})
				
				local function ChangeState(State)
					if State == "Idle" then
						Tween(ButtonInteract, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {TextTransparency = 0.5}):Play()
						Tween(ButtonImage, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {ImageTransparency = 0.5}):Play()
					elseif State == "Hover" then
						Tween(ButtonInteract, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {TextTransparency = 0.3}):Play()
						Tween(ButtonImage, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {ImageTransparency = 0.3}):Play()
					end
				end
				
				ButtonInteract.MouseEnter:Connect(function()
					ChangeState("Hover")
				end)
				
				ButtonInteract.MouseLeave:Connect(function()
					ChangeState("Idle")
				end)
				
				ButtonInteract.MouseButton1Click:Connect(function()
					if not Button.Disabled then
						Library:SafeCallback(Button.Func)
					end
				end)
				
				function Button:SetText(Text)
					ButtonInteract.Text = Text
				end
				
				function Button:SetDisabled(Disabled)
					Button.Disabled = Disabled
					ButtonInteract.Active = not Disabled
				end
				
				Groupbox:AddBlank(5)
				table.insert(Groupbox.Elements, Button)
				table.insert(Buttons, Button)
				
				return Button
			end
			
			function Groupbox:AddToggle(Idx, Info)
				Info.Text = Info.Text or "Toggle"
				Info.Default = Info.Default or false
				Info.Callback = Info.Callback or function() end
				
				local Toggle = {
					Value = Info.Default,
					Type = "Toggle",
					Text = Info.Text,
					Disabled = Info.Disabled,
					Risky = Info.Risky,
					Callback = Info.Callback,
					Addons = {},
				}
				
				local ToggleFrame = Library:Create("Frame", {
					Name = "Toggle",
					AutomaticSize = Enum.AutomaticSize.Y,
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Size = UDim2.new(1, 0, 0, 38),
					Parent = Groupbox.Container,
				})
				
				local ToggleName = Library:CreateLabel({
					Name = "ToggleName",
					Text = Info.Text,
					TextSize = 13,
					TextTransparency = 0.5,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Top,
					AnchorPoint = Vector2.new(0, 0.5),
					AutomaticSize = Enum.AutomaticSize.XY,
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.fromScale(0, 0.5),
					Size = UDim2.new(1, -50, 0, 0),
					Parent = ToggleFrame,
				})
				
				local ToggleButton = Library:Create("ImageButton", {
					Name = "Toggle",
					Image = assets.toggleBackground,
					ImageColor3 = Color3.fromRGB(61, 61, 61),
					AnchorPoint = Vector2.new(1, 0.5),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.fromScale(1, 0.5),
					Size = UDim2.fromOffset(41, 21),
					AutoButtonColor = false,
					Parent = ToggleFrame,
				})
				
				Library:Create("UIPadding", {
					PaddingBottom = UDim.new(0, 1),
					PaddingLeft = UDim.new(0, -2),
					PaddingRight = UDim.new(0, 3),
					PaddingTop = UDim.new(0, 1),
					Parent = ToggleButton,
				})
				
				local TogglerHead = Library:Create("ImageLabel", {
					Name = "TogglerHead",
					Image = assets.togglerHead,
					ImageColor3 = Color3.fromRGB(91, 91, 91),
					AnchorPoint = Vector2.new(1, 0.5),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.new(0.5, 0, 0.5, 0),
					Size = UDim2.fromOffset(15, 15),
					ZIndex = 2,
					Parent = ToggleButton,
				})
				
				local function ToggleState(State)
					if State then
						Tween(ToggleButton, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {ImageColor3 = Color3.fromRGB(87, 86, 86)}):Play()
						Tween(TogglerHead, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {ImageColor3 = Color3.fromRGB(255, 255, 255)}):Play()
						Tween(TogglerHead, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {Position = UDim2.new(1, 0, 0.5, 0)}):Play()
					else
						Tween(ToggleButton, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {ImageColor3 = Color3.fromRGB(61, 61, 61)}):Play()
						Tween(TogglerHead, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {ImageColor3 = Color3.fromRGB(91, 91, 91)}):Play()
						Tween(TogglerHead, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {Position = UDim2.new(0.5, 0, 0.5, 0)}):Play()
					end
				end
				
				ToggleState(Toggle.Value)
				
				ToggleButton.MouseButton1Click:Connect(function()
					if not Toggle.Disabled then
						Toggle.Value = not Toggle.Value
						ToggleState(Toggle.Value)
						Library:SafeCallback(Toggle.Callback, Toggle.Value)
						Library:AttemptSave()
					end
				end)
				
				function Toggle:SetValue(Value)
					Toggle.Value = Value
					ToggleState(Value)
					Library:SafeCallback(Toggle.Callback, Value)
					Library:AttemptSave()
				end
				
				function Toggle:SetDisabled(Disabled)
					Toggle.Disabled = Disabled
					ToggleButton.Active = not Disabled
				end
				
				function Toggle:AddKeyPicker(Idx, Info)
					local KeyPicker = {
						Value = nil,
						Modifiers = {},
						DisplayValue = nil,
						Toggled = false,
						Mode = Info.Mode or "Toggle",
						Type = "KeyPicker",
						Callback = Info.Callback or function() end,
						ChangedCallback = Info.ChangedCallback or function() end,
						SyncToggleState = Info.SyncToggleState or false,
					}
					
					if KeyPicker.Mode == "Press" then
						KeyPicker.SyncToggleState = false
						Info.Modes = {"Press"}
						Info.Mode = "Press"
					end
					
					if KeyPicker.SyncToggleState then
						Info.Modes = {"Toggle"}
						Info.Mode = "Toggle"
					end
					
					local Picking = false
					local SpecialKeys = {["MB1"] = Enum.UserInputType.MouseButton1, ["MB2"] = Enum.UserInputType.MouseButton2, ["MB3"] = Enum.UserInputType.MouseButton3}
					local SpecialKeysInput = {[Enum.UserInputType.MouseButton1] = "MB1", [Enum.UserInputType.MouseButton2] = "MB2", [Enum.UserInputType.MouseButton3] = "MB3"}
					
					local Modifiers = {
						["LAlt"] = Enum.KeyCode.LeftAlt,
						["RAlt"] = Enum.KeyCode.RightAlt,
						["LCtrl"] = Enum.KeyCode.LeftControl,
						["RCtrl"] = Enum.KeyCode.RightControl,
						["LShift"] = Enum.KeyCode.LeftShift,
						["RShift"] = Enum.KeyCode.RightShift,
						["Tab"] = Enum.KeyCode.Tab,
						["CapsLock"] = Enum.KeyCode.CapsLock,
					}
					
					local ModifiersInput = {
						[Enum.KeyCode.LeftAlt] = "LAlt",
						[Enum.KeyCode.RightAlt] = "RAlt",
						[Enum.KeyCode.LeftControl] = "LCtrl",
						[Enum.KeyCode.RightControl] = "RCtrl",
						[Enum.KeyCode.LeftShift] = "LShift",
						[Enum.KeyCode.RightShift] = "RShift",
						[Enum.KeyCode.Tab] = "Tab",
						[Enum.KeyCode.CapsLock] = "CapsLock",
					}
					
					local function IsModifierInput(Input)
						return Input.UserInputType == Enum.UserInputType.Keyboard and ModifiersInput[Input.KeyCode] ~= nil
					end
					
					local function GetActiveModifiers()
						local ActiveModifiers = {}
						for Name, Input in Modifiers do
							if InputService:IsKeyDown(Input) then
								table.insert(ActiveModifiers, Name)
							end
						end
						return ActiveModifiers
					end
					
					local function AreModifiersHeld(Required)
						if not Required or #Required == 0 then return true end
						local ActiveModifiers = GetActiveModifiers()
						for _, Name in Required do
							if not table.find(ActiveModifiers, Name) then
								return false
							end
						end
						return true
					end
					
					local PickOuter = Library:Create("Frame", {
						BackgroundTransparency = 1,
						Size = UDim2.new(0, 28, 0, 15),
						ZIndex = 6,
						Parent = ToggleFrame,
					})
					
					local PickInner = Library:Create("Frame", {
						BackgroundColor3 = Library.BackgroundColor,
						BorderColor3 = Library.OutlineColor,
						BorderMode = Enum.BorderMode.Inset,
						Size = UDim2.new(1, 0, 1, 0),
						ZIndex = 7,
						Parent = PickOuter,
					})
					
					Library:AddToRegistry(PickInner, {BackgroundColor3 = "BackgroundColor", BorderColor3 = "OutlineColor"})
					
					local DisplayLabel = Library:CreateLabel({
						Size = UDim2.new(1, 0, 1, 0),
						TextSize = 13,
						Text = Info.Default,
						ZIndex = 8,
						Parent = PickInner,
					})
					
					function KeyPicker:Display(Text)
						DisplayLabel.Text = Text or KeyPicker.DisplayValue
						PickOuter.Size = UDim2.new(0, 999999, 0, 18)
						RunService.RenderStepped:Wait()
						PickOuter.Size = UDim2.new(0, math.max(28, DisplayLabel.TextBounds.X + 8), 0, 18)
					end
					
					function KeyPicker:SetValue(Data, SkipCallback)
						local Key, Mode, Modifiers = Data[1], Data[2], Data[3]
						local IsKeyValid, UserInputType = pcall(function()
							if Key == "None" then
								Key = nil
								return nil
							end
							if SpecialKeys[Key] == nil then
								return Enum.KeyCode[Key]
							end
							return SpecialKeys[Key]
						end)
						
						if Key == nil then
							KeyPicker.Value = "None"
						elseif IsKeyValid then
							KeyPicker.Value = Key
						else
							KeyPicker.Value = "Unknown"
						end
						
						KeyPicker.Modifiers = Modifiers or {}
						KeyPicker.DisplayValue = #KeyPicker.Modifiers > 0 and (table.concat(KeyPicker.Modifiers, " + ") .. " + " .. KeyPicker.Value) or KeyPicker.Value
						DisplayLabel.Text = KeyPicker.DisplayValue
						
						KeyPicker:Display()
						
						if not SkipCallback then
							local NewModifiers = {}
							for _, name in KeyPicker.Modifiers do
								table.insert(NewModifiers, Modifiers[name])
							end
							Library:SafeCallback(KeyPicker.ChangedCallback, UserInputType, NewModifiers)
						end
					end
					
					function KeyPicker:GetState()
						if KeyPicker.Mode == "Always" then
							return true
						elseif KeyPicker.Mode == "Hold" then
							local Key = KeyPicker.Value
							if Key == "None" then return false end
							if not AreModifiersHeld(KeyPicker.Modifiers) then return false end
							if SpecialKeys[Key] ~= nil then
								return InputService:IsMouseButtonPressed(SpecialKeys[Key]) and not InputService:GetFocusedTextBox()
							else
								return InputService:IsKeyDown(Enum.KeyCode[Key]) and not InputService:GetFocusedTextBox()
							end
						else
							return KeyPicker.Toggled
						end
					end
					
					PickOuter.InputBegan:Connect(function(Input)
						if Input.UserInputType == Enum.UserInputType.MouseButton1 and not Library:MouseIsOverOpenedFrame() then
							Picking = true
							KeyPicker:Display("...")
							local InputResult
							while true do
								task.wait()
								InputResult = InputService.InputBegan:Wait()
								if not InputService:GetFocusedTextBox() then break end
							end
							if InputResult.KeyCode == Enum.UserInputType.Keyboard and InputResult.KeyCode == Enum.KeyCode.Escape then
								KeyPicker:SetValue({nil, KeyPicker.Mode, {}})
							else
								local Key = "Unknown"
								if SpecialKeysInput[InputResult.UserInputType] ~= nil then
									Key = SpecialKeysInput[InputResult.UserInputType]
								elseif InputResult.UserInputType == Enum.UserInputType.Keyboard then
									Key = InputResult.KeyCode == Enum.KeyCode.Escape and "None" or InputResult.KeyCode.Name
								end
								KeyPicker:SetValue({Key, KeyPicker.Mode, GetActiveModifiers()})
							end
							RunService.RenderStepped:Wait()
							Picking = false
						end
					end)
					
					Library:GiveSignal(InputService.InputBegan:Connect(function(Input)
						if KeyPicker.Value == "Unknown" then return end
						if not Picking and not InputService:GetFocusedTextBox() then
							local Key = KeyPicker.Value
							local HoldingModifiers = AreModifiersHeld(KeyPicker.Modifiers)
							if HoldingModifiers then
								if Input.UserInputType == Enum.UserInputType.Keyboard and Input.KeyCode.Name == Key then
									if KeyPicker.Mode == "Toggle" then
										KeyPicker.Toggled = not KeyPicker.Toggled
										Library:SafeCallback(KeyPicker.Callback, KeyPicker.Toggled)
									elseif KeyPicker.Mode == "Press" then
										Library:SafeCallback(KeyPicker.Callback, true)
									end
								elseif SpecialKeysInput[Input.UserInputType] == Key then
									if KeyPicker.Mode == "Toggle" then
										KeyPicker.Toggled = not KeyPicker.Toggled
										Library:SafeCallback(KeyPicker.Callback, KeyPicker.Toggled)
									elseif KeyPicker.Mode == "Press" then
										Library:SafeCallback(KeyPicker.Callback, true)
									end
								end
							end
						end
					end))
					
					KeyPicker:SetValue({Info.Default, Info.Mode or "Toggle", {}}, true)
					table.insert(Toggle.Addons, KeyPicker)
					
					return KeyPicker
				end
				
				function Toggle:AddColorPicker(Idx, Info)
					local ColorPicker = {
						Value = Info.Default,
						Transparency = Info.Transparency or 0,
						Type = "ColorPicker",
						Title = Info.Title or "Color picker",
						Callback = Info.Callback or function() end,
					}
					
					ColorPicker.Hue, ColorPicker.Sat, ColorPicker.Vib = Color3.toHSV(ColorPicker.Value)
					
					local DisplayFrame = Library:Create("ImageLabel", {
						Name = "NewColor",
						Image = "rbxassetid://121484455191370",
						ScaleType = Enum.ScaleType.Tile,
						TileSize = UDim2.fromOffset(500, 500),
						AnchorPoint = Vector2.new(1, 0.5),
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						Position = UDim2.fromScale(1, 0.5),
						Size = UDim2.fromOffset(21, 21),
						Parent = ToggleFrame,
					})
					
					local ColorFrame = Library:Create("Frame", {
						AnchorPoint = Vector2.new(0.5, 0.5),
						BackgroundColor3 = ColorPicker.Value,
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromScale(1, 1),
						BackgroundTransparency = ColorPicker.Transparency,
						Parent = DisplayFrame,
					})
					
					Library:Create("UICorner", {CornerRadius = UDim.new(0, 6), Parent = ColorFrame})
					
					local Interact = Library:Create("TextButton", {
						Text = "",
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						Size = UDim2.fromScale(1, 1),
						Parent = ColorFrame,
					})
					
					Library:Create("UICorner", {CornerRadius = UDim.new(0, 8), Parent = DisplayFrame})
					
					local ColorPickerFrame = Library:Create("Frame", {
						Name = "ColorPicker",
						BackgroundTransparency = 0.5,
						BorderSizePixel = 0,
						Size = UDim2.fromScale(1, 1),
						Visible = false,
						ZIndex = 15,
						Parent = ScreenGui,
					})
					
					Library:Create("UICorner", {CornerRadius = UDim.new(0, 10), Parent = ColorPickerFrame})
					
					local Prompt = Library:Create("Frame", {
						Name = "Prompt",
						AnchorPoint = Vector2.new(0.5, 0.5),
						AutomaticSize = Enum.AutomaticSize.Y,
						BackgroundColor3 = Color3.fromRGB(15, 15, 15),
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0.5, 0.5),
						Size = UDim2.fromOffset(420, 0),
						Parent = ColorPickerFrame,
					})
					
					Library:Create("UIStroke", {
						ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
						Color = Color3.fromRGB(255, 255, 255),
						Transparency = 0.9,
						Parent = Prompt,
					})
					
					function ColorPicker:Show()
						ColorPickerFrame.Visible = true
					end
					
					function ColorPicker:Hide()
						ColorPickerFrame.Visible = false
					end
					
					function ColorPicker:SetValue(HSV, Transparency)
						if typeof(HSV) == "Color3" then
							ColorPicker.Value = HSV
						else
							ColorPicker.Value = Color3.fromHSV(HSV[1], HSV[2], HSV[3])
						end
						ColorPicker.Transparency = Transparency or 0
						ColorFrame.BackgroundColor3 = ColorPicker.Value
						ColorFrame.BackgroundTransparency = ColorPicker.Transparency
						Library:SafeCallback(ColorPicker.Callback, ColorPicker.Value, ColorPicker.Transparency)
					end
					
					Interact.MouseButton1Click:Connect(function()
						ColorPicker:Show()
					end)
					
					ColorPicker:SetValue(ColorPicker.Value, ColorPicker.Transparency)
					table.insert(Toggle.Addons, ColorPicker)
					
					return ColorPicker
				end
				
				Library.Toggles[Idx] = Toggle
				Toggle.Default = Toggle.Value
				table.insert(Groupbox.Elements, Toggle)
				
				return Toggle
			end
			
			function Groupbox:AddSlider(Idx, Info)
				Info.Text = Info.Text or "Slider"
				Info.Min = Info.Min or 0
				Info.Max = Info.Max or 100
				Info.Default = Info.Default or Info.Min
				Info.Rounding = Info.Rounding or 1
				Info.Compact = Info.Compact or false
				Info.HideMax = Info.HideMax or false
				Info.Suffix = Info.Suffix or ""
				Info.ChangedCallback = Info.ChangedCallback or function() end
				Info.Callback = Info.Callback or function() end
				
				local Slider = {
					Value = Info.Default,
					Min = Info.Min,
					Max = Info.Max,
					Rounding = Info.Rounding,
					Compact = Info.Compact,
					HideMax = Info.HideMax,
					Suffix = Info.Suffix,
					Callback = Info.Callback,
					ChangedCallback = Info.ChangedCallback,
					Type = "Slider",
				}
				
				local SliderFrame = Library:Create("Frame", {
					Name = "Slider",
					AutomaticSize = Enum.AutomaticSize.Y,
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Size = UDim2.new(1, 0, 0, 38),
					Parent = Groupbox.Container,
				})
				
				local SliderName = Library:CreateLabel({
					Name = "SliderName",
					Text = Info.Text,
					TextSize = 13,
					TextTransparency = 0.5,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Top,
					AnchorPoint = Vector2.new(0, 0.5),
					AutomaticSize = Enum.AutomaticSize.XY,
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.fromScale(0, 0.5),
					Parent = SliderFrame,
				})
				
				local SliderElements = Library:Create("Frame", {
					Name = "SliderElements",
					AnchorPoint = Vector2.new(1, 0),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.fromScale(1, 0),
					Size = UDim2.fromScale(1, 1),
					Parent = SliderFrame,
				})
				
				local SliderValue = Library:Create("TextBox", {
					Name = "SliderValue",
					Text = tostring(Slider.Value),
					TextSize = 12,
					TextTransparency = 0.4,
					AnchorPoint = Vector2.new(1, 0.5),
					AutomaticSize = Enum.AutomaticSize.X,
					BackgroundTransparency = 0.95,
					BorderSizePixel = 0,
					ClipsDescendants = true,
					LayoutOrder = 1,
					Position = UDim2.fromScale(1, 0.5),
					Size = UDim2.fromOffset(41, 21),
					Parent = SliderElements,
				})
				
				Library:Create("UICorner", {CornerRadius = UDim.new(0, 4), Parent = SliderValue})
				Library:Create("UIStroke", {
					ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
					Color = Color3.fromRGB(255, 255, 255),
					Transparency = 0.9,
					Parent = SliderValue,
				})
				
				Library:Create("UIPadding", {
					PaddingLeft = UDim.new(0, 2),
					PaddingRight = UDim.new(0, 2),
					Parent = SliderValue,
				})
				
				local SliderElementsLayout = Library:Create("UIListLayout", {
					Padding = UDim.new(0, 20),
					FillDirection = Enum.FillDirection.Horizontal,
					HorizontalAlignment = Enum.HorizontalAlignment.Right,
					SortOrder = Enum.SortOrder.LayoutOrder,
					VerticalAlignment = Enum.VerticalAlignment.Center,
					Parent = SliderElements,
				})
				
				local SliderBar = Library:Create("ImageLabel", {
					Name = "SliderBar",
					Image = assets.sliderBar,
					ImageColor3 = Color3.fromRGB(87, 86, 86),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.fromScale(0.219, 0.457),
					Size = UDim2.fromOffset(123, 3),
					Parent = SliderElements,
				})
				
				local SliderHead = Library:Create("ImageButton", {
					Name = "SliderHead",
					Image = assets.sliderHead,
					AnchorPoint = Vector2.new(0.5, 0.5),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.fromScale(1, 0.5),
					Size = UDim2.fromOffset(12, 12),
					Parent = SliderBar,
				})
				
				Library:Create("UIPadding", {
					PaddingTop = UDim.new(0, 3),
					Parent = SliderElements,
				})
				
				local Dragging = false
				
				local function UpdateValue(Value, IgnoreCallback)
					local NewValue = math.clamp(Value, Slider.Min, Slider.Max)
					Slider.Value = NewValue
					SliderHead.Position = UDim2.fromScale((NewValue - Slider.Min) / (Slider.Max - Slider.Min), 0.5)
					SliderValue.Text = tostring(NewValue)
					if not IgnoreCallback then
						Library:SafeCallback(Slider.Callback, NewValue)
					end
				end
				
				UpdateValue(Slider.Value, true)
				
				SliderHead.InputBegan:Connect(function(Input)
					if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
						Dragging = true
					end
				end)
				
				SliderHead.InputEnded:Connect(function(Input)
					if Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch then
						Dragging = false
					end
				end)
				
				InputService.InputChanged:Connect(function(Input)
					if Dragging and (Input.UserInputType == Enum.UserInputType.MouseMovement or Input.UserInputType == Enum.UserInputType.Touch) then
						local RelativeX = (Input.Position.X - SliderBar.AbsolutePosition.X) / SliderBar.AbsoluteSize.X
						local NewValue = Slider.Min + RelativeX * (Slider.Max - Slider.Min)
						UpdateValue(NewValue)
					end
				end)
				
				SliderValue.FocusLost:Connect(function()
					local NewValue = tonumber(SliderValue.Text)
					if NewValue then
						UpdateValue(NewValue)
					else
						SliderValue.Text = tostring(Slider.Value)
					end
				end)
				
				function Slider:SetValue(Value)
					UpdateValue(Value)
					Library:AttemptSave()
				end
				
				function Slider:GetValue()
					return Slider.Value
				end
				
				Library.Options[Idx] = Slider
				Slider.Default = Slider.Value
				table.insert(Groupbox.Elements, Slider)
				
				return Slider
			end
			
			function Groupbox:AddInput(Idx, Info)
				Info.Text = Info.Text or "Input"
				Info.Default = Info.Default or ""
				Info.Numeric = Info.Numeric or false
				Info.Placeholder = Info.Placeholder or ""
				Info.Callback = Info.Callback or function() end
				
				local Textbox = {
					Value = Info.Default,
					Numeric = Info.Numeric,
					Finished = Info.Finished or false,
					Visible = Info.Visible ~= false,
					Disabled = Info.Disabled or false,
					AllowEmpty = Info.AllowEmpty ~= false,
					EmptyReset = Info.EmptyReset or "---",
					Type = "Input",
					Callback = Info.Callback,
				}
				
				local InputFrame = Library:Create("Frame", {
					Name = "Input",
					AutomaticSize = Enum.AutomaticSize.Y,
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Size = UDim2.new(1, 0, 0, 38),
					Parent = Groupbox.Container,
				})
				
				local InputName = Library:CreateLabel({
					Name = "InputName",
					Text = Info.Text,
					TextSize = 13,
					TextTransparency = 0.5,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Top,
					AnchorPoint = Vector2.new(0, 0.5),
					AutomaticSize = Enum.AutomaticSize.XY,
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.fromScale(0, 0.5),
					Parent = InputFrame,
				})
				
				local InputBox = Library:Create("TextBox", {
					Name = "InputBox",
					Text = Info.Default,
					PlaceholderText = Info.Placeholder,
					TextSize = 12,
					TextTransparency = 0.4,
					AnchorPoint = Vector2.new(1, 0.5),
					AutomaticSize = Enum.AutomaticSize.X,
					BackgroundTransparency = 0.95,
					BorderSizePixel = 0,
					ClipsDescendants = true,
					LayoutOrder = 1,
					Position = UDim2.fromScale(1, 0.5),
					Size = UDim2.fromOffset(21, 21),
					Parent = InputFrame,
				})
				
				Library:Create("UICorner", {CornerRadius = UDim.new(0, 4), Parent = InputBox})
				Library:Create("UIStroke", {
					ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
					Color = Color3.fromRGB(255, 255, 255),
					Transparency = 0.9,
					Parent = InputBox,
				})
				
				Library:Create("UIPadding", {
					PaddingLeft = UDim.new(0, 5),
					PaddingRight = UDim.new(0, 5),
					Parent = InputBox,
				})
				
				local Constraint = Library:Create("UISizeConstraint", {Parent = InputBox})
				
				local function CheckSize()
					local NameWidth = InputName.AbsoluteSize.X
					local TotalWidth = InputFrame.AbsoluteSize.X
					local MaxWidth = TotalWidth - NameWidth - 20
					Constraint.MaxSize = Vector2.new(MaxWidth, 9e9)
				end
				
				CheckSize()
				InputName:GetPropertyChangedSignal("AbsoluteSize"):Connect(CheckSize)
				
				function Textbox:SetValue(Text)
					if not Textbox.AllowEmpty and Trim(Text) == "" then
						Text = Textbox.EmptyReset
					end
					Textbox.Value = Text
					InputBox.Text = Text
					Library:SafeCallback(Textbox.Callback, Text)
				end
				
				if Textbox.Finished then
					InputBox.FocusLost:Connect(function(Enter)
						if Enter then
							Textbox:SetValue(InputBox.Text)
							Library:AttemptSave()
						end
					end)
				else
					InputBox:GetPropertyChangedSignal("Text"):Connect(function()
						Textbox:SetValue(InputBox.Text)
						Library:AttemptSave()
					end)
				end
				
				if Info.Tooltip or Info.DisabledTooltip then
					Library:AddToolTip(Info.Tooltip, Info.DisabledTooltip, InputBox)
				end
				
				Library.Options[Idx] = Textbox
				Textbox.Default = Textbox.Value
				table.insert(Groupbox.Elements, Textbox)
				
				return Textbox
			end
			
			function Groupbox:AddDropdown(Idx, Info)
				Info.SpecialType = Info.SpecialType or "None"
				if Info.SpecialType == "Player" then
					Info.Values = GetPlayers(Info.ExcludeLocalPlayer, Info.ReturnInstances)
					Info.AllowNull = true
				elseif Info.SpecialType == "Team" then
					Info.Values = GetTeams(Info.ReturnInstances)
					Info.AllowNull = true
				end
				
				Info.Values = Info.Values or {}
				Info.Default = Info.Default or (Info.AllowNull and nil or 1)
				Info.Multi = Info.Multi or false
				Info.Searchable = Info.Searchable or false
				Info.Callback = Info.Callback or function() end
				Info.Changed = Info.Changed or function() end
				
				local Dropdown = {
					Values = Info.Values,
					Value = Info.Multi and {} or nil,
					Multi = Info.Multi,
					Type = "Dropdown",
					Callback = Info.Callback,
					Changed = Info.Changed,
				}
				
				local DropdownFrame = Library:Create("Frame", {
					Name = "Dropdown",
					BackgroundTransparency = 0.985,
					BorderSizePixel = 0,
					Size = UDim2.new(1, 0, 0, 38),
					ClipsDescendants = true,
					Parent = Groupbox.Container,
				})
				
				Library:Create("UIPadding", {
					PaddingLeft = UDim.new(0, 15),
					PaddingRight = UDim.new(0, 15),
					Parent = DropdownFrame,
				})
				
				local Interact = Library:Create("TextButton", {
					Name = "Interact",
					Text = "",
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Size = UDim2.new(1, 0, 0, 38),
					Parent = DropdownFrame,
				})
				
				local DropdownName = Library:CreateLabel({
					Name = "DropdownName",
					Text = Info.Name,
					TextSize = 13,
					TextTransparency = 0.5,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextTruncate = Enum.TextTruncate.SplitWord,
					AutomaticSize = Enum.AutomaticSize.Y,
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Size = UDim2.new(1, -20, 0, 38),
					Parent = DropdownFrame,
				})
				
				Library:Create("UIStroke", {
					ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
					Color = Color3.fromRGB(255, 255, 255),
					Transparency = 0.95,
					Parent = DropdownFrame,
				})
				
				Library:Create("UICorner", {CornerRadius = UDim.new(0, 6), Parent = DropdownFrame})
				
				local DropdownImage = Library:Create("ImageLabel", {
					Name = "DropdownImage",
					Image = assets.dropdownArrow,
					ImageTransparency = 0.5,
					AnchorPoint = Vector2.new(1, 0),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					Position = UDim2.new(1, 0, 0, 12),
					Size = UDim2.fromOffset(14, 14),
					Parent = DropdownFrame,
				})
				
				local DropdownContent = Library:Create("Frame", {
					Name = "DropdownFrame",
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					ClipsDescendants = true,
					Size = UDim2.fromScale(1, 1),
					Visible = false,
					AutomaticSize = Enum.AutomaticSize.Y,
					Parent = DropdownFrame,
				})
				
				Library:Create("UIPadding", {
					PaddingTop = UDim.new(0, 38),
					PaddingBottom = UDim.new(0, 10),
					Parent = DropdownContent,
				})
				
				local DropdownContentLayout = Library:Create("UIListLayout", {
					Padding = UDim.new(0, 5),
					SortOrder = Enum.SortOrder.LayoutOrder,
					Parent = DropdownContent,
				})
				
				local SearchFrame
				if Info.Searchable then
					SearchFrame = Library:Create("Frame", {
						Name = "Search",
						BackgroundTransparency = 0.95,
						BorderSizePixel = 0,
						LayoutOrder = -1,
						Size = UDim2.new(1, 0, 0, 30),
						Parent = DropdownContent,
					})
					
					Library:Create("UICorner", {Parent = SearchFrame})
					
					local SearchIcon = Library:Create("ImageLabel", {
						Name = "SearchIcon",
						Image = assets.searchIcon,
						ImageColor3 = Color3.fromRGB(180, 180, 180),
						AnchorPoint = Vector2.new(0, 0.5),
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0, 0.5),
						Size = UDim2.fromOffset(12, 12),
						Parent = SearchFrame,
					})
					
					Library:Create("UIPadding", {PaddingLeft = UDim.new(0, 15), Parent = SearchFrame})
					
					local SearchBox = Library:Create("TextBox", {
						Name = "SearchBox",
						PlaceholderText = "Search...",
						Text = "",
						TextSize = 14,
						TextColor3 = Color3.fromRGB(200, 200, 200),
						TextXAlignment = Enum.TextXAlignment.Left,
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						Size = UDim2.fromScale(1, 1),
						Parent = SearchFrame,
					})
					
					Library:Create("UIPadding", {PaddingLeft = UDim.new(0, 23), Parent = SearchBox})
				end
				
				local OptionObjects = {}
				local SelectedValues = {}
				
				local function ToggleOption(Name, State)
					local Option = OptionObjects[Name]
					if not Option then return end
					
					if State then
						if Info.Multi then
							SelectedValues[Name] = true
						else
							SelectedValues = {[Name] = true}
						end
					else
						SelectedValues[Name] = nil
					end
					
					local SelectedCount = 0
					local SelectedNames = {}
					for Name, Selected in SelectedValues do
						if Selected then
							SelectedCount = SelectedCount + 1
							table.insert(SelectedNames, Name)
						end
					end
					
					if SelectedCount > 0 then
						DropdownName.Text = Info.Name .. "  " .. table.concat(SelectedNames, ", ")
					else
						DropdownName.Text = Info.Name
					end
					
					Library:SafeCallback(Info.Callback, Dropdown.Value)
				end
				
				local function AddOption(Name)
					local OptionFrame = Library:Create("TextButton", {
						Name = "Option",
						Text = "",
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						Size = UDim2.new(1, 0, 0, 30),
						Parent = DropdownContent,
					})
					
					Library:Create("UIPadding", {PaddingLeft = UDim.new(0, 15), Parent = OptionFrame})
					
					local OptionName = Library:CreateLabel({
						Name = "OptionName",
						Text = Name,
						TextSize = 13,
						TextTransparency = 0.5,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextTruncate = Enum.TextTruncate.AtEnd,
						AnchorPoint = Vector2.new(0, 0.5),
						AutomaticSize = Enum.AutomaticSize.XY,
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						Position = UDim2.fromScale(0, 0.5),
						Parent = OptionFrame,
					})
					
					local OptionLayout = Library:Create("UIListLayout", {
						Padding = UDim.new(0, 10),
						FillDirection = Enum.FillDirection.Horizontal,
						SortOrder = Enum.SortOrder.LayoutOrder,
						VerticalAlignment = Enum.VerticalAlignment.Center,
						Parent = OptionFrame,
					})
					
					local Checkmark = Library:CreateLabel({
						Name = "Checkmark",
						Text = "",
						TextSize = 13,
						TextTransparency = 1,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextYAlignment = Enum.TextYAlignment.Top,
						AnchorPoint = Vector2.new(0, 0.5),
						AutomaticSize = Enum.AutomaticSize.Y,
						BackgroundTransparency = 1,
						BorderSizePixel = 0,
						LayoutOrder = -1,
						Position = UDim2.fromScale(0, 0.5),
						Size = UDim2.fromOffset(-10, 0),
						Parent = OptionFrame,
					})
					
					OptionObjects[Name] = {
						Button = OptionFrame,
						NameLabel = OptionName,
						Checkmark = Checkmark,
					}
					
					OptionFrame.MouseButton1Click:Connect(function()
						local IsSelected = SelectedValues[Name] or false
						ToggleOption(Name, not IsSelected)
					end)
				end
				
				for _, Name in Info.Values do
					AddOption(Name)
				end
				
				local Dropped = false
				local Debounce = false
				
				local function ToggleDropdown()
					if Debounce then return end
					Debounce = true
					Dropped = not Dropped
					
					local TargetSize = Dropped and UDim2.new(1, 0, 0, 300) or UDim2.new(1, 0, 0, 38)
					Tween(DropdownFrame, TweenInfo.new(0.2, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {Size = TargetSize}):Play()
					
					if Dropped then
						DropdownContent.Visible = true
						Tween(DropdownImage, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {Rotation = 180}):Play()
					else
						Tween(DropdownImage, TweenInfo.new(0.2, Enum.EasingStyle.Sine), {Rotation = 0}):Play()
					end
					
					task.wait(0.2)
					if not Dropped then
						DropdownContent.Visible = false
					end
					Debounce = false
				end
				
				Interact.MouseButton1Click:Connect(ToggleDropdown)
				
				function Dropdown:SetValue(Value)
					if Info.Multi then
						SelectedValues = {}
						for _, Name in Value do
							SelectedValues[Name] = true
						end
					else
						SelectedValues = {[Value] = true}
					end
					Library:SafeCallback(Info.Callback, Value)
				end
				
				Library.Options[Idx] = Dropdown
				table.insert(Groupbox.Elements, Dropdown)
				
				return Dropdown
			end
			
			return Groupbox
		end
		
		table.insert(Window.Tabs, Tab)
		
		if Library.ActiveTab == nil then
			Tab:Show()
		end
		
		return Tab
	end
	
	if Settings.AutoShow then
		Window.Holder.Visible = true
	end
	
	Library.Window = Window
	
	return Window
end

function Library:Notify(Text, Duration)
	Duration = Duration or 5
	
	local Notification = Library:Create("Frame", {
		Name = "Notification",
		AnchorPoint = Vector2.new(1, 0),
		BackgroundColor3 = Color3.fromRGB(15, 15, 15),
		BorderSizePixel = 0,
		Position = UDim2.fromScale(1, 1),
		Size = UDim2.fromOffset(300, 60),
		ZIndex = 2,
		Parent = ScreenGui,
	})
	
	Library:Create("UICorner", {CornerRadius = UDim.new(0, 10), Parent = Notification})
	Library:Create("UIStroke", {
		ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
		Color = Color3.fromRGB(255, 255, 255),
		Transparency = 0.9,
		Parent = Notification,
	})
	
	local Padding = Library:Create("UIPadding", {
		PaddingBottom = UDim.new(0, 10),
		PaddingLeft = UDim.new(0, 10),
		PaddingRight = UDim.new(0, 10),
		PaddingTop = UDim.new(0, 10),
		Parent = Notification,
	})
	
	local Layout = Library:Create("UIListLayout", {
		Padding = UDim.new(0, 10),
		HorizontalAlignment = Enum.HorizontalAlignment.Right,
		SortOrder = Enum.SortOrder.LayoutOrder,
		VerticalAlignment = Enum.VerticalAlignment.Bottom,
		Parent = Notification,
	})
	
	local Title = Library:CreateLabel({
		Text = "Notification",
		TextSize = 16,
		TextXAlignment = Enum.TextXAlignment.Left,
		LayoutOrder = 1,
		Parent = Notification,
	})
	
	local Message = Library:CreateLabel({
		Text = Text,
		TextSize = 14,
		TextTransparency = 0.3,
		TextXAlignment = Enum.TextXAlignment.Left,
		LayoutOrder = 2,
		Parent = Notification,
	})
	
	Tween(Notification, TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.Out), {
		Position = UDim2.new(1, -10, 1, -10),
	}):Play()
	
	task.delay(Duration, function()
		Tween(Notification, TweenInfo.new(0.3, Enum.EasingStyle.Exponential, Enum.EasingDirection.In), {
			Position = UDim2.new(1, 10, 1, 10),
		}):Play()
		task.wait(0.3)
		Notification:Destroy()
	end)
end

function Library:OpenConsole()
	if not ConsoleUI then
		ConsoleUI = Library:Create("Frame", {
			Name = "Console",
			AnchorPoint = Vector2.new(0, 1),
			BackgroundColor3 = Color3.fromRGB(20, 20, 20),
			BorderColor3 = Color3.fromRGB(40, 40, 40),
			Position = UDim2.fromOffset(10, 400),
			Size = UDim2.fromOffset(570, 200),
			ZIndex = 100,
			Parent = ScreenGui,
		})
		
		Library:Create("UIListLayout", {
			Padding = UDim.new(0, 5),
			FillDirection = Enum.FillDirection.Vertical,
			SortOrder = Enum.SortOrder.LayoutOrder,
			Parent = ConsoleUI,
		})
		
		Library:Create("UIPadding", {
			PaddingBottom = UDim.new(0, 10),
			PaddingLeft = UDim.new(0, 10),
			PaddingRight = UDim.new(0, 10),
			PaddingTop = UDim.new(0, 10),
			Parent = ConsoleUI,
		})
	end
	
	ConsoleUI.Visible = not ConsoleUI.Visible
end

function Library:Validate(Table, Template)
	if typeof(Table) ~= "table" then
		return Template
	end
	for k, v in pairs(Template) do
		if typeof(k) == "number" then
			continue
		end
		if typeof(v) == "table" then
			Table[k] = Library:Validate(Table[k], v)
		elseif Table[k] == nil then
			Table[k] = v
		end
	end
	return Table
end

function Library:AddThemeManager()
	local ThemeManager = {}
	
	function ThemeManager:SetTheme(Theme)
		Theme = Library:Validate(Theme, {
			MainColor = Color3.fromRGB(15, 15, 15),
			BackgroundColor = Color3.fromRGB(15, 15, 15),
			AccentColor = Color3.fromRGB(255, 255, 255),
			OutlineColor = Color3.fromRGB(255, 255, 255),
			FontColor = Color3.fromRGB(255, 255, 255),
		})
		
		for Property, Color in pairs(Theme) do
			Library[Property] = Color
		end
		
		Library:UpdateColorsUsingRegistry()
	end
	
	function ThemeManager:SaveDefault()
		ThemeManager.DefaultTheme = {
			MainColor = Color3.fromRGB(15, 15, 15),
			BackgroundColor = Color3.fromRGB(15, 15, 15),
			AccentColor = Color3.fromRGB(255, 255, 255),
			OutlineColor = Color3.fromRGB(255, 255, 255),
			FontColor = Color3.fromRGB(255, 255, 255),
		}
	end
	
	function ThemeManager:LoadDefault()
		if ThemeManager.DefaultTheme then
			ThemeManager:SetTheme(ThemeManager.DefaultTheme)
		end
	end
	
	Library.ThemeManager = ThemeManager
	
	return ThemeManager
end

function Library:AddSaveManager()
	local SaveManager = {}
	
	function SaveManager:Save(FileName)
		local Data = {}
		for Idx, Toggle in next, Library.Toggles do
			Data[Idx] = {Type = "Toggle", Value = Toggle.Value}
		end
		for Idx, Option in next, Library.Options do
			if Option.Type == "KeyPicker" then
				Data[Idx] = {Type = "KeyPicker", Value = Option.Value, Modifiers = Option.Modifiers}
			elseif Option.Type == "ColorPicker" then
				Data[Idx] = {Type = "ColorPicker", Value = {Option.Hue, Option.Sat, Option.Vib}, Transparency = Option.Transparency}
			elseif Option.Type == "Dropdown" then
				Data[Idx] = {Type = "Dropdown", Value = Option.Value}
			elseif Option.Type == "Input" then
				Data[Idx] = {Type = "Input", Value = Option.Value}
			elseif Option.Type == "Slider" then
				Data[Idx] = {Type = "Slider", Value = Option.Value}
			end
		end
		if writefile then
			writefile(FileName .. ".json", HttpService:JSONEncode(Data))
		end
	end
	
	function SaveManager:Load(FileName)
		if not isfile or not isfile(FileName .. ".json") then
			return
		end
		local Data = HttpService:JSONDecode(readfile(FileName .. ".json"))
		for Idx, Value in next, Data do
			local Object = Library.Toggles[Idx] or Library.Options[Idx]
			if Object then
				if Object.Type == "Toggle" then
					Object:SetValue(Value.Value)
				elseif Object.Type == "KeyPicker" then
					Object:SetValue(Value.Value, Value.Modifiers)
				elseif Object.Type == "ColorPicker" then
					Object:SetValue(Value.Value, Value.Transparency)
				elseif Object.Type == "Dropdown" then
					Object:SetValue(Value.Value)
				elseif Object.Type == "Input" then
					Object:SetValue(Value.Value)
				elseif Object.Type == "Slider" then
					Object:SetValue(Value.Value)
				end
			end
		end
	end
	
	function SaveManager:SetIgnoreIndexes(Indexes)
		SaveManager.IgnoreIndexes = Indexes
	end
	
	function SaveManager:SetFolder(Folder)
		SaveManager.Folder = Folder
		if makefolder and not isfolder(Folder) then
			makefolder(Folder)
		end
	end
	
	function SaveManager:Refresh()
		local List = listfiles and listfiles(SaveManager.Folder) or {}
		for _, File in next, List do
			if File:sub(-5) == ".json" then
				local FileName = File:match("^.+[/\\](.+)%..+$")
				if not SaveManager.IgnoreIndexes or not table.find(SaveManager.IgnoreIndexes, FileName) then
					table.insert(SaveManager.Files, FileName)
				end
			end
		end
	end
	
	function SaveManager:SaveConfiguration(Name)
		if not SaveManager.Folder then
			SaveManager:SetFolder("MacLib")
		end
		local FileName = SaveManager.Folder .. "/" .. Name
		SaveManager:Save(FileName)
	end
	
	function SaveManager:LoadConfiguration(Name)
		if not SaveManager.Folder then
			SaveManager:SetFolder("MacLib")
		end
		local FileName = SaveManager.Folder .. "/" .. Name
		SaveManager:Load(FileName)
	end
	
	function SaveManager:GetConfigurations()
		SaveManager:Refresh()
		return SaveManager.Files
	end
	
	SaveManager.Files = {}
	
	Library.SaveManager = SaveManager
	
	return SaveManager
end

function Library:OnInterfaceToggle()
	Library.CantDragForced = true
	Library.CanDrag = false
	task.wait(0.2)
	Library.CantDragForced = false
	Library.CanDrag = true
end

function Library:SetWindowVisibility(Visible)
	Library.Window.Holder.Visible = Visible
end

getgenv().MacLib = Library

return Library